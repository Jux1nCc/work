# day12-mobile

## 概述

### 复习

详情页面：

+ 解决回复面板数据的加载 bug
+ 完成了评论回复的添加

我的页面：

+ 静态页面
+ 动态渲染数据

个人信息页面：

+ 静态页面
+ 动态渲染数据
  + 数据的来源有两个：
    + 得到头像 & 昵称 & 介绍
    + 得到性别 & 生日
+ 数据的修改
+ 图片的上传
  + 封装一个上面图片的面板
  + 给从相册选择添加点击事件：
    + 在页面上添加一个上传框，并且隐藏起来
    + 给从相册选择添加点击事件，在事件中调用上传框的点击事件
  + 选择图片
    + 给上传框添加一个图片的改变事件：change 事件
  + 预览图片
    + 使用 vant 中的 预览 组件来预览图片
  + 点击预览图片关闭图片
    + 给预览组件设置一个 onClose 事件
    + 在事件中话询问用户是否将图片设置为头像
  + 向图片提交到服务器
    + 接收服务器返回的图片的路径
  + 将图片路径传入到个人信息页面
    + 接收图片，并且渲染到页面上
  + 注意点：
    + 预览图片时，需要将图片从文件对象转为 url
      + 可使用 FileRead
    + 关闭事件可以 onclose 来设置
    + 上传图片时，应该将图片包裹到 formdate 对象中

### 今日内容

websocket：

+ 是什么
+ 怎么用
+ 完成一个案例

小智同学

## WebSocket

### WebSocket - 什么是WebSocket

> 它与 http 协议一样，也是一种通讯协议

http 协议：

+ 作用：规范浏览器与服务器交互的一种标准。

+ 特点：
  + 每次浏览器与服务器之间进行交互都需要重复开启和断开连接
  + 请求只能由浏览器主动发送，服务器被动响应
+ 总结：
  + 由于以上两个特点，让 http 协议在某些场合下不适用。比如说：实时聊天。

websocket  协议

>  它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话 

+ 作用：一种通讯协议

+ 特点：
  + 一旦浏览器与服务器建立连接之后，不会轻易断开
  + 交互可以由服务器主动发起，也可以由浏览器主动发起
+ 总结：
  + 由于 websocket 的两个特点，它非常适合用来完成实时聊天

### WebSocket - 基本使用

[示例传送门](http://www.ruanyifeng.com/blog/2017/05/websocket.html )

对照图：

![1586919351209](img\1586919351209.png)

总结： websocket 的运行流程

+  1）需要一个服务器
+  2）需要一个客户端（浏览器）
+  3）由客户端连接服务器
+  4）服务器端响应连接成功的状态
+  5）由客户端向服务器发送消息
+  6）服务器接收消息
+  7）服务器响应消息到客户端
+  8）客户端接收消息
+  9）关闭连接

###  WebSocket - 简单的客户端演示：

> 这里是一个简单的**客户端**显示，所以服务器是人家已经建好的

```js
var ws = new WebSocket('wss://echo.websocket.org')
ws.onopen = function () { 
    console.log('连接已经成功了')
    ws.send('hello world') 
}
ws.onmessage = function (evt) {
    console.log('接收到的消息为:' + evt.data)
    ws.close()
}
ws.onclose = function () {
    console.log('连接已经关闭')
}
```

### 复习上午

websocket：

+ 什么是 weboscket：
  + 与 http 协议一样，都是一种通讯协议
  + 特点：
    + 一旦浏览器与服务器建立连接，一般情况下连接通道不会断开
    + 可以由服务器主动传递数据到浏览器
+ 完成简单的客户端案例：
  + 使用 js 中的 websocket 对象，来完成与服务器的交互
  + 注意点： websocket 对象是实现 websocket 协议的一个对象
+ 使用 websocket 完成聊天室

### WebSocket - 完成一个聊天室

> 使用一个基于 websocket 的第三方包 socket.io 来完成聊天室
>
> > 服务器
> >
> > 客户端

demo[传送门](https://socket.io/get-started/chat/)

步骤：

+ 1.0 创建一个服务器
  + 创建一个文件夹
  + 初始化这个项目： npm init -y
  + 下载 express
  + 使用 express 来开启服务器
+ 2.0 创建一个客户端
  + 在项目中创建一个文件夹：`views`
  + 在文件夹中创建一个静态页面 index.html
  + 在 index.html 完成聊天的结构
  + 在请求根目录时，将这个 html 页面响应浏览器，当作客户端
+ 3.0 在服务器中开启 websocket
  + 在服务器中下载 socket.io
  + 在服务器中开启 socket.io 
+ 4.0 在客户端中连接这个 websocket 
  + 在客户端页面中导入 socket.io 文件
  + 在客户端页面中创建一个 socket.io 对象
+ 5.0 客户端向服务器发送消息
  + 导入 jquery
  + 给 form 元素添加一个提交事件
  + 在事件中：
    + 将输入框中的内容提交到服务器
      + **socket.emit('sendmsg',  xxx)**
    + 提交之后将输入框清空
+ 6.0 服务器接收客户端的消息
  + 在 connection 中接收客户端传入的消息
    + **socket.on('sendmsg' , xxx => {  })**
+ 7.0 服务器响应客户端消息
  + 在接收到消息之后，可以直接将消息返回给客户端
    + **socket.emit('serverSend', xxx)**
+ 8.0 客户端接收服务器消息
  + **scoket.on('serverSend', xxx => {})**

总结：

+ 客户端向服务器发送数据：
  + `socket.emit(key, value)`
+ 服务器接收客户端数据：
  + `socket.on(key, v => { // v 就是接收的参数 })`
+ 服务器向客户端发送数据
  + 消息回复：`socket.emit(key, value)`
  + 消息广播：`socket.on(key, v => {} )`
+ 客户端接收服务器的数据
  + `socket.on(key, v => {})`

## 小智同学

### 小智同学 - 创建组件

+ 创建组件 & 创建路由
+ 设置入口

### 小智同学 - 完成静态页面

头部标题

聊天区域

+ 设置内容高度时会出现一个问题：
  + 由于不同的手机型号的高度是不一样的，但是聊天区域的高度必须是整个页面除去头部 & 底部的高度。
+ 解决方案：
  + 不给这个盒子设置一个固定高度
  + 给这个盒子设置一个定位（固定定位）
    + 给盒子同时设置 `top` & `bottom` 属性
    + 将来盒子的高度就是 `top` 与 `bottom` 之间距离

信息发送

### 小智同学 - 完成聊天

功能分析：

+ 1.0 打开页面时，机器人会说：你好啊，我是小智。同学
+ 2.0 用户回复：任意内容
+ 3.0 机器人再进行回复

实现步骤：

+ a. 创建一个数组：用来保存聊天信息

  ```js
  // 数组的结构
  var chatArr = [
      // content: 聊天的内容  isRoboto: 是否是机器人的对话
      { content: '聊天的内容', isRoboto: true },
      { content: '聊天的内容', isRoboto: false }
  ]
  ```

+ b. 将数组中的内容动态渲染到页面上

+ c. 发送聊天内容到服务器：

  + 在 `onSearch` 事件中：

    + 将输入框中的内容添加到 `chatArr` 中

    + 将内容提交到服务器

      + 请求服务器的接口（聊天机器人）

        + 请求地址：http://ttapi.research.itcast.cn?token=xxxxx

        + 请求方式： `socket.io`

        + 发送数据：

          ```js
          socket.emit('message', {
          	msg: '', // 聊天的内容
              timestamp: '' // 时间戳
          })
          ```

        + 接收数据：

          ```js
          socket.on('message', data => {
          	// data: { msg: '', timestamp: '' }
          })
          ```

      + 在项目中导入第三方包 `socket.io`

        + 下载 `socket.io-client`
        + 导入 `socket.io-client`
        + 创建一个 `socket` 对象
        + 使用 `socket` 进行交互

    + 清空输入框中的内容

+ d. 接收服务器响应的数据

  + 在 `mounted` 中通过 `this.socket.on('message', v=> {})` 来接收数据
  + 将接收到的数据保存到 `chatArr`

+ 注意点：
  + 提交到服务器的接口使用的 websocket 协议，需要使用 socket.io 客户端的第三方包
    + 下载第三方包：`npm i socket.io-client`
    + 导入第三方包： `import socket from 'socket.io-client'`
    + 使用第三方包：
      + 连接服务器： `var conn = socket('xxx.xxx.xx')`
      + 发送信息：`conn .emit(key, value)`
      + 接收信息：`conn .on(key, value => {})`

## 补充：面试题

### 请求说出：

从浏览器的地址栏中输入内容点击回车，到看到页面的显示，这段期间发生了些什么？

![1588842388053](C:\Users\91300\Desktop\vue-mobile\day12\1-教学资料\p4-浏览器与服务器的交互过程.png)



三次握手的过程：

+ 作用：浏览器与服务器建立连接通道
+ 过程：
  + 第一步：
    + 客户端：发送请求到服务器，要建立连接
  + 第二步：
    + 服务器：接收到客户端的请求，并且同意
  + 第三步：
    + 客户端：发送请求，确认连接

四次挥手的过程：

+ 作用：浏览器与服务器断开连接通道

+ 过程：

  + 第一步：
    + 客户端：发送请求到服务器，要关闭连接，并且处于等待关闭状态1
  + 第二步：
    + 服务器：接收客户端的请求，响应信息，同意关闭连接，并且自己也处于等待关闭的状态

  + 第三步：
    + 服务器：再次发送请求到客户端，关闭连接。再次处理等待关闭的状态
  + 第四步：
    + 客户端：接收到关闭的指令，关闭服务器，最后发送一条已经关闭的消息给服务器

[传送门](https://blog.csdn.net/qq_38950316/article/details/81087809)



