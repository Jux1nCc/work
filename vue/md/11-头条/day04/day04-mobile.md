# day04-mobile

## 概述

### 复习

改造项目结构：

+ 删除了项目中不需要的文件
+ 添加了项目中需要的文件

vant 的使用：

+ 在 vue 中使用 vant
+ vant 中的组件的使用：
  + 按钮
  + 单元格
  + 字体图标
+ vant 中的插槽

登录：

+ 静态页面
+ 验证参数的合法性
+ 提交参数到服务器
+ axios 文件的封装
+ 封装了网络请求的 api

+ 使用 async & await 来改造代码
+ 将登录成功后的用户信息保存起来
  + vuex 中：
    + state：保存数据（状态）
      + userInfo
    + mutations：操作数据（状态）
      + setUserInfo

### 今日内容

登录：

+ 完成其它任务

首页：

+ 完成静态页面
+ 完成其它功能

## 登录

### 登录 - 保存登录信息到 vuex 中

> 登录成功之后，在跳转到首页之前，应该将用户信息保存起来。数据的保存会保存到两个位置：
>
> > stoer： 保存到仓库中
> >
> > > 为了方便将来在书写项目时使用
> >
> > localstorage ：保存到本地
> >
> > > 为了重新打开页面，保存的状态依旧存在

步骤：

+ 1.0 在 `store` 中 的 `state` 下创建一个属性： `userInfo`
+ 2.0 在 `store` 中的 `mutations` 下创建一个方法： `setUserInfo`
  + 在方法中给 `userInfo` 赋值
+ 3.0 登录成功之后，应该直接将服务器返回的数据保存到 `store` 中的 `userInfo`

### 登录 - 保存登录信息到 localstorage 中

步骤：

+ 1.0 将用户信息保存到本地： `localstorage`
+ 2.0 默认打开项目时，应该将 `locastorage` 中的数据取出来，放到 `userInfo` 中

### 登录 - localstoreage 的操作方法封装

> 由于将来我们会频繁的对 localstroage 进行操作， 我们可以将操作的步骤封装为一些单独的方法放到一个单独的文件中

步骤：

+ 1.0 在 `utils` 下添加一个文件 `mylocal.js`
+ 2.0 在 `mylocal.js` 文件中封装方法：
  + 存储数据的方法： localSet
  + 取出数据的方法： localGet
  + 删除数据的方法： localDel
+ 3.0 将方法暴露出去

注意点：

+ 取出数据 的方法中需要设置一个 `return`

### 登录 -  给登录添加加载效果

> 登录时，网络可能比较慢，如果不作处理，用户会认为自己没有登录。会多次点击登录按钮。会额外的消耗服务器的性能。

任务：当用户点击一次登录之后，将登录按钮设置为加载状态。

准备知识点：

+ 给按钮添加一个 loading 属性：
  + 值为 true：按钮就会处于加载状态
  + 值为 false：按钮就会处于可用状态

步骤：

+ 1.0 给按钮添加一个 `loading` 属性
+ 2.0 在 `data` 中设置一个 `isLoding` 属性，默认值为 `false`
+ 3.0 在点击按钮时
  + 将 `isLoading` 设置为 true
+ 4.0 当服务器响应回来之后
  + 将 `isLoading` 设置为 false

### 登录 - try-catch的基本使用

> 由于黑马头条接口在登录失败时直接返回一个 400，400 会将浏览器直接报错，无法正常执行后续的代码。要解决这个问题，可以使用 try-catch 来捕获错误

try-catch 的用法：

```js
try {
	// 可以会出错的代码
} catch (error) {
	// 如果出错，就执行 catch 中的代码，
    // 如果不出错，就不执行 catch 中的代码
    // error: 指的就是出错的信息
}
```

try-catch 的作用：

+ 正常执行 try 中的逻辑：
  + 如果没有问题就一直执行下去（不执行 catch 中的逻辑）
  + 如果在 try 中的代码有错误，就会马上中断 try 中的逻辑去执行 catch 中的逻辑

### 登录 - 捕获登录失败信息

步骤：

+ 1.0 将 `login` 方法中登录逻辑的代码使用 `try-catch` 包裹起来

### 登录 - 给登录失败添加提示框

> vant 中的提示框是 [toast](https://youzan.github.io/vant/#/zh-CN/toast) 

提示失败： 

+ ` Toast.fail('失败文案'); `

注意点：

+ Toast 使用时与 `element` 中的 `message` 是一样的
  + 如果在 `.vue`  文件中使用： `this.$toast.fail('')`
  + 如果在其它的 `.js` 文件中使用：
    + 导入这个 Toast：`import { Toast } from 'vant'`
    + 使用这个 Toast： `Toast.fail('失败的文案')`
+ 如果在完成登录页面时我们没有使用 `async & awiat` 关键字来改造 js 逻辑，那么在这种情况下用不了 `try-catch`
  + 因为在 `axios` 内部其实已经有了解决错误的方法：`axios().then().catch()`

### 复习上午

登录：

+ 将用户登录信息保存到 localstorage 中
+ 将操作 localstorage  的代码封装为方法
+ 添加登录加载效果
+ 使用 try-catch
+ 添加失败的提示框：
  + `toast`：一般在组件中使用时是提示框的意思。翻译为中文是：吐司。

首页

+ 创建组件：
  + 设置了一个父组件：完成了底部的 tabBar
+ 静态页面：
  + 头部导航

## 首页

### 首页 - 创建组件

步骤：

+ 1.0 在 `views` 下面创建一个 `index`
+ 2.0 设置路由
+ 3.0 设置默认跳转路由为 `index`

布局情况：

+ 头部标题
+ 频道区域
+ 频道下文章区域
+ 底部 tabBar 区域

### 首页 -  提取底部 tabBar

> 由于四个页面中都用到 tabBar， 可以将 home 作为父组件，用来显示底部的 tabBar，将其它四个页面作为 home 的子组件来渲染就可以了

步骤：

+ 1.0 在 `home` 中添加一个底部的 `tabBar`
  + 可以使用 vant 中的组件：[tabBar](https://youzan.github.io/vant/#/zh-CN/tabbar)
    + 要点击不同的 tab 选项跳转到不同的页面：需要设置 `tabBar`  的属性 router 
      + 用来开启路由模式
+ 2.0 创建四个页面：主页（index），问答，视频，我的（my）
  + 将这四个页面作为为 `home`  的子页面存在

### 首页 - 头部标题结构

### 首页 - 频道区域结构

> 使用 vant 中的 [tab 组件](https://youzan.github.io/vant/#/zh-CN/tab)

### 首页 - 文章区域结构

> 说明如果要文章区域可以上拉加载更多，需要使用到 vant 中的一个组件：list 组件
>
> 属性：
>
> > v-model：是否处于正在上拉加载更多的操作
> >
> > finished：list 数据源中的数据是否完全加载完成
>
> 事件：
>
> > load：当 List 组件在上拉加载更多时，会执行的事件

步骤：

+ 1.0 使用 `list` 组件将文章内容包裹起来

### 首页 - 固定头部&频道区域

步骤：

+ 1.0 将头部导航固定起来
+ 2.0 将频道区域固定起来

### 首页 - 频道操作按钮布局

> 在频道区域的右侧添加一个按钮

步骤：

+ 1.0 在页面上添加一个容器：设置按钮
+ 2.0 给容器设置固定定位：定到屏幕的右上角
+ 3.0 设置宽度为 10%
+ 4.0 修改频道结构的宽度为 90%

### 首页 - 上拉加载更多

>  问题：由于黑马头条是一个新闻类的网站，需要向上滑动时加载更多的信息，需要完成上拉加载更多
>
>  方案：可以使用 vant 中的组件来完成：  [list](https://youzan.github.io/vant/#/zh-CN/list) 

案例：

+ 1.0 默认情况下 list 组件中会显示 0 条数据
+ 2.0 在 List 组件中 会先加载 15 条数据
+ 3.0 当上拉触底时，再加载 15 条数据
+ 4.0  当数据源的总条数据达到 60 条时，停止加载数据

注意点：

```
// 执行时机：
//   1.0 当 list 组件被加载时会执行一次
//   2.0 当页面的滚动条触底时会再次执行 onload
// 注意点
//   1.0 onload 如果要执行必须保证 list 组件的 v-model 对应的值的为 false
//   2.0 每次 onload 执行之后会自动将 v-model 对应的值设置为 true，
//        所在每次 onload 执行完成之后需要手动将 v-model 对应的值改为 false
//   3.0 如果 list 的 finished 属性为 true, 那么 onload 事件不会再执行
```

+ 1.0 要进行内容拼接时，不用 push ，用`[...this.list, ...arr]`

### 首页 - 下拉刷新结构

> 要实现下拉刷新，需要单独添加一个组件：[PullRefresh](https://youzan.github.io/vant/#/zh-CN/pull-refresh) 

PullRefresh

+ 属性：
  + v-model：isloading 
    + 作用：用来表示下拉刷新的状态
    + true：处于下拉刷新中，无法再次执行 `refresh` 事件
    + false：下拉刷新完成

+ 事件：
  + `refresh` ：
    + 作用：下拉刷新时触发
    + 触发之后会将 v-model 对应的值改为 true，需要手动将这个值修改回 false

任务：

+ 当下拉之后：
  + 1.0 将 list 组件中渲染的数据的长度重置为 0 
  + 2.0 将 list 组件可以继续上拉加载更多

### 首页 - 加载频道数据

步骤：

+ a. 在 `mounted&created` 中请求服务器接口，得到频道数据
  + 接口： 获取用户频道列表
+ b. 将返回的频道数据保存起来
+ c. 将频道数据渲染到页面上

### 首页 - 给请求设置 token

> 获取频道数据的接口其实是这一种情况：
>
> >没有传入 Authorization（token）： 只会得到默认的 7 条频道数据
> >
> >传入了 Authorization（token） ：就会得到当前登录用户的频道数据
>
> 由于在项目中有很多像获取频道数据一样的接口，它们都可以传入 Authorization，来得到用户自己的信息。也可以不传 Authorization 得到默认数据
>
> > 需求：如果在 localstorage（vuex） 中 token 就应该放到请求头中，如果 localstorage（vuex） 中没有频道数据，就不用传。
> >
> > 解决方案：在每次发送请求（不管是任意请求）时，都先判断一个 vuex 中是否有用户的 token，如果有，将 token 添加到请求头中，如果没有，不管了。**可以在 axios 的请求拦截器中判断 vuex 中是否存在 token，如果存在直接将 token 携带在请求头中**

步骤：

+ a. 在 `utils/myhttp.js` 文件中的请求拦截器
  + 得到 `store` 对象
  + 判断 `store` 中的 `state` 下的 `userInfo` 是否存在属性 `token`
    + 如果存在 ，就将 `token` 以 `Authorization` 为键，以 `token` 为值，传入到请求头中
    + 如果不存在，不用理会

注意点：

+ 1.0 向请求头中添加 `token` 时：
  + 键为： `Authorization`
  + 值为： `Bearer ` + `token` （格式为： Bearer + 空格）
+ 2.0 取得 `store` 中的 token 中时
  + 先将 `store` 对象导入
+ 3.0 如果添加了 `Authroization` 之后反而得到不频道数据：
  + 需要重新登录（token 过期了）
+ 4.0 token 的效期只有 2 个小时 

### 首页 - 判断频道数据

> 频道数据来源：
>
> > 如果登录
> >
> > > 直接从服务器中得到当前用户的频道数据
> >
> > 如果没有登录
> >
> > > 判断：当前 localstorage 中是否存在频道数据
> > >
> > > > 存在：直接从 localstorage 中取出频道数据，进行渲染
> > > >
> > > > 不存在：直接从服务器中得到默认的 7 条频道数据

步骤：

+ 1.0 找到 `mounted`， 将直接获取频道数据的操作删除掉
+ 2.0 进行判断：
  + 判断用户是否登录（判断 `vuex` 中是否存在 `token`）
    + 如果登录：
      + 直接从服务器中得到用户自己的频道信息
    + 如果未登录：
      + 判断 `localstorage` 中是否存在频道数据
        + 如果存在：
          + 直接取出渲染到页面上
        + 如果不存在：
          + 直接从服务器中得到默认的 7条频道数据

### 首页 - 将不同频道下的数据分开

> 由于不同的频道下的数据源是不一样的，所以将来要正确渲染数据需要给每个频道都设置一组自己的数据
>
> > 文章的数据源：articleList
> >
> > list 组件的加载状态： loading
> >
> > list 组件的加载完结状态： finished
> >
> > pull-refresh 组件的加载状态： isLoading

步骤：

+ 1.0  当我们从服务器中得到了频道数据之后：

  ```json
  {
  	channels: [
  		{id:0,name:'推荐'},
  		{id:11,name:'后端'}
  	]
  }
  ```

+ 2.0 应该在每个频道数据下添加这些额外属性： articleList & loading & finished & isLoading

  ```json
  {
  	channels: [
  		{id:0,name:'推荐',articleList:[],loading:false,finished:false,isLoading:false},
  		{id:11,name:'后端',articleList:[],loading:false,finished:false,isLoading:false}
  	]
  }
  ```

+ 3.0 将添加的数据在页面上动态渲染

### 首页 - 渲染频道下的文章数据

> 得到当前选中频道的数据对象：可以给 van-tab 设置一个 `v-model` 属性

步骤：

+ 1.0 确定当前切换的频道的 id
  + 给 van-tbas 添加一个属性：`v-model=“active”`
  + 在 data 中添加一个属性：`active: 0` 
  + 可以通过以下表达式得到频道的 `id`：`this.channelList[this.active].id`
+ 2.0 在 `list` 组件的 `onload` 事件中添加逻辑代码
  + 得到当前切换的频道的 `id`
  + 发送请求到服务器去得到当前频道对应的文章数据
  + 将数据渲染到页面上

注意点：

+ 1.0 请求频道下的新闻有两个接口，需要使用第二个：频道新闻推荐_V1.1
+ 2.0 加载完文章数据之后，页面不会马上显示这个数据，先切换到另一个频道之后再切换回来才会执行
  + 这个问题的解决方案：this.$set()

### 首页 - 上拉加载更多

+ 问题1：文章数据渲染完成之后，页面上一直处于加载状态。
  + 原因： list 刚执行完 load 事件，load事件会将 List的加载状态改为 true。
  + 解决方式：将当前频道下的 list 的加载状态手动改为 false
+ 问题2：当修改加载状态之后，页面就像抽风了一样。请求发一直发送，页面上显示的数据会一直切换。
  + 原因：就是我们每次得到数据之后，使用新的数据将老的数据覆盖掉了，我们页面上的数据永远只有一页的数据（10条）
  + 解决方式：只需要将每次得到的数据接收到原来的数据中就可以了
+ 问题3：当我们切换到某一频道下时， 会一直发送请求，但是没有数据
  + 原因：是因为当前频道下面没有数据
  + 解决方式：只需要判断一个从服务器中返回的文章数据的长度是否为 0
    + 如果为 0 ：将当前频道下的 finished 属性改为 true
    + 如果不为0：不用理解

### 首页 - 下拉刷新

步骤：

+ a. 在 `onRefresh` 事件中
  + 清除当前频道下的所有数据
  + 重新加载数据